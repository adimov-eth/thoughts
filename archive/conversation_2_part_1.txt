ты от этого получишь безопасность сам. Нельзя строить протокол, такой инцентив, что ты должен хранить исторические блоки, потому что никакие новые блоки на них слазать не могут. Понимаешь? То есть они по определению... Ты можешь попросить, ну пожалуйста, ну храните, но никто не обязан их хранить, потому что это невозможно проверить, невозможно заинфорсить. То есть еще до всяких изменений, связанных с RLAP, старые блоки могли удалять каждые две недели. Просто Etherscan и остальные их хранили. Это первый уровень. А второй уровень, когда они с Cold Data перепрыгнули в Blob Space. То есть это другой уровень данных, еще более дешевый, который даже не попадает на полноды, потому что его видят только уровень валидаторов. То есть это еще более дешевая Cold Data, которая даже не попадает в LZM. Понимаешь? И вот ее уже официально хранят на 16-14 дней, было написано. То есть ее прямо точно уже нету. Вот сейчас ты не можешь Ubase скачать за месяц последнюю историю. Кто не успел, тот не сел. И если сейчас с XVC BASE RTO выключается, нет никакой гарантии, что кто-то другой сможет восстановить его состояние и продолжить, и вывести ассеты. То есть это огромный системный риск. Source, trust me, bro, да, я понимаю. Ты полагаешься на Trust BASE, и тогда ты приходишь просто к тем же самым банкам, только еще и неудобным. Еще и неудобным, и еще и который выстрелит один раз пожестче, чем в каком-нибудь FTX. Потому что FTX хотя бы имел балансы, которые ну хоть как-то раскидали, там потом вернули. А это будет типа пожар в дата-центре, и нет балансов вообще. Ну типа не знаем, кому сколько должны, есть один рутовый хэш в блокчейне эфира. Ну не знаю, как вернуть. Куча, этот контракт Layer 1 внутри эфира держит на себе огромное количество токенов золочных. А вот кому что именно приближает, уже как бы никто не знает. Потому что сиквенсер обрабатывал 200 тысяч продакций в секунду, и никто кроме сиквенсера не вкладывал бабки, чтобы за ним это повторять и поддерживать актуальный стейт. Так, а теперь ну просто чтобы на контрасте. Потому что ты гораздо четче раскладываешь, чем я бы мог это разложить. Почему… Ну это называется Data Availability. Да, а почему XLN ебет это в рот? А потому что по самой системе дизайна нету проблемы Data Availability, потому что ты фулл нода всех вот этих трех машин. Ты полная нода юрисдикции, потому что у тебя состояние всего вот этого блокчейна локально. Но это опционально, то есть в идеале это реализуемо. Второе, ты фулл нода сущности, которая представляет из тебя вот этого суверенного актера, которым ты взаимодействуешь с юрисдикцией. И ты фулл нода всех каналов, которые внутри сущности, потому что они как бы вложены внутри сущности. Соответственно, если ебнутся вообще все, у тебя всегда есть диспет-пруфы, которые… ты идешь в юрисдикцию, то есть у тебя полная суверенность данных. Ты не зависишь от третьих серверов, которые должны что-то хранить. А в ROLAP-ах ты всегда зависишь от того, что SQL сохранит полный стейт, и включит ли он твою транзакцию на выход или нет, это уже от него зависит. То есть ты просто light client, по сути, всегда в ROLAP-ах. Это раз. То есть, по сути, две основных метрики — security и scalability. И вот в обоих этих метриках ROLAP-ы сосут. Потому что это worst of both worlds. То есть у них scalability по определению ограничен, потому что блок-спейс, он тоже не резиновый, ну сколько там, тысячи, десять тысяч транзакций в секунду они могут делать. А миру надо миллионы. А в каналах можно популяризовать миллионы, потому что они как интернет, они совершенно независимые. Вот мы с тобой разговариваем, мы не стучим о том, что мы разговариваем. А у них общий bottleneck. Согласен, согласен. Эту часть я как раз понимаю, я все еще тренируюсь на тем, как... То есть их словами будут и в scalability, и в security. Оба параметра в десятки раз мощнее. То есть я тренирую пока скилл того, как это... Ну то есть у тебя это понимание, ты оттачивал его довольно много лет, то есть оно сформировалось давно, ты его отточил, и ты очень четко прям по пунктам раскладываешь. Я оттачиваю мастерство, чтобы людям донести, почему это так. Короче, я Джун, ты уже старец преисполнившийся. Нет проблем, конечно. Я готов себя объяснять тысячу раз. Я стараюсь, брат, спасибо тебе, что... Мне самому нравится объяснять, я же могу бесконечно вообще это объяснить. Еще очень хочется, чтобы ты заработала, блядь. Потому что никто в эту сторону даже не работает, даже поглядите. Просто крипта уже затухла, в принципе. Сейчас все на АИ перешли, все умные люди выбирают работать на АИ. Криптя уже типа западло. Ну да, а скажи, а что там эти АДА делают? Ты сказал, что они тоже какие-то каналы делают. Гидра? Да, да. Я сам пейпер не читал, потому что, как ты понимаешь, это хаскилисты что-то там математику намутили, но я прогнал через ЛМКИС, прогнал. Ну в принципе они ничем от ладника не отличаются, просто под модель кардана. Такие же каналы полностью резервированные, то есть они запущутся и никому не будет трудно. То есть они не догадались понять, в чем проблема лайтинга. Бюджет просто выделили под это и пилит то же самое. А вот напомни на всякий случай, чтобы у меня тоже под рукой было, чем мы лучше лайтинга? Ну это многослойный ответ. Самое основное изменение и отличие от лайтинга, лайтинг и каналы, они работают традиционно по принципу полного резервирования. Фулл резерв ченнел, так сказать, или фулл резерв аккаунт. Это одно и то же. То есть, чтобы по цепочке пролетели деньги, надо, чтобы резервирование было во всей цепочке. От Алиса к Хабу, от Хабу к Бобу. И если на первом этапе Алиса к Хабу понятно, почему? Потому что Алиса малотрастовая сущность, а Хаб высокотрастовый, то Алиса должна залаживать, закладывать резерв заранее. Тут окей. Тут как бы лайтинг работает очевидно. И в XLM тоже самое будет. Ты сначала должен резерв заложить. Но когда второй и третий этап, то Хаб получателю, он не заинтересован закладывать резерв. Для него это стоит бабок. Для него это стоит бродкаст юрисдикции. Понимаешь? Я это понимаю. Это охуенно. Я это понимаю давно. У меня не получается так складно и по фактам многоуровнево разъебывать так, как ты это делаешь. То же самое понимаю и пытаюсь выразить, но типа глубина твоего понимания столько больше, что ты ебешь это словами. Ну короче, в рэп баттле ты бы меня нагнул за один гаундер. Буквально вчера пересматривал Гнойный против Оксимирона. Блин, как же Оксимирон кринжовый, там реально 5-0. Оксимирон выебал Джонни По, а также Гнойный выебал Оксимирон. Обожаю Гнойного. Да, мне там трек залетел. Нас делают равны, что-то там. YouTube предлагает, прям сразу феврит добавил. Очень метафорно-метафори охуенно сделал. Там еще на это, оказывается, делают что-то типа рутуб пупов. Ну типа нарезка, короче. И короче, что? Да, я сейчас гляну. Жак, короче, про кредиты. Смотри. Сущность основная. Роллапы, первое. Фундаментальный боттлнек. Фундаментальный проблем безопасности. Потому что это availability. Как мы поняли. Да. Боттлнек, потому что блокспейс не резиновый. Это масштабируется на 10 тысяч, 100 тысяч, окей. А миру надо миллионы и даже, может быть, миллиарды в будущем. Когда огромное количество и агентов, у людей будет больше денег. И просто экономическая активность вырастет. То есть миру по-хорошему на XLN стремится миллиард ТПС. Потому что только Unicast-система, не связанных между собой транзакций, может это поддерживать. И банковская система точно так же сейчас работает. То есть это hub-and-spoke. Просто банковская система, она построена на не связанных друг к другу протоколах, и поэтому она тормозит. Такие уайси. Так-то ей ничего не ограничивает поддерживать миллиард ТПС. Это просто бегущие как через хабы транзакции. Так вот, а вторая проблема роллапов – это security, что ее вообще никак не решить. То есть просто это dead-end research, вся редкая исследование. Она разваливается от простого условия. Сиквенсер наебнулся, what's next? И не существует безопасности, которая тебя защитит от этой проблемы. Даже если это закара-роллапы с максимальной безопасностью. Даже если они enshrined. Enshrined-роллапы – это те, которые строены прямо в EWM, а не коммунируемые, так сказать, на VM-ке. А почему они не тащат? Ничто из этого не решает проблему Data Availability. То есть вообще, все, что Виталик делал с момента релиза EWM, идеально. Это как бы то, что он сделал Original Vitalik Vision. Потом в каждом посте, я читал его старые посты, он говорит, Ethereum должен запускаться на каждом ноутбуке. Я с этим согласен. То есть это Original Vision – заебись. Но потом все пошло по пизделам, потому что увидел, ну что-то нихуя неумещаемая транзакция, а чтобы конкурировать, надо повышать GAS-лимит. И GAS-лимит улетел 10 в 100 раз. Потом появился Bloopspace. То есть сейчас на ноутбуке Bloopspace уже не скачаешь никогда, потому что это сотни гигабайтов, наверное, уже в день даже будет. То есть он уже отошел от Original Vision. Вот XLN идеально работает на Ethereum, который был в 2015-м за релизом. Просто Proof-of-Work надо заменить на Proof-of-Stake. И вот как бы Original Vision плюс XLN – это прям охуенно имбовая комбинация. И все идеи Vitalik с того момента, ну, мне кажется, хуйня. Потому что Plasma была, тоже Data Availability проблема. Sharding был. Сейчас о нем никто не говорит. Тоже Data Availability. Потому что, когда ты разбиваешь вот этот монолитный стейк, у тебя оказывается, что любой отдельный шард, если он взломан, то он взламывает всю систему. И никакой Provable Randomness эту проблему не решит. Поэтому Sharding они и разговорчики закрыли. Потом появился Plasma Cache – тоже хуйня. Что еще? Потом, собственно, пришли к ROLAPO. ROLAPO выбрали по той причине, что они EVM-компетитивны. То есть Plasma не поддерживает полностью EVM. А за ROLAPO вцепились просто потому, что это как EVM на втором слое. То есть, ну, когда у людей что-то получается, они логично пытаются делать именно это. Что зарешало в эфире – это именно EVM. Вот этот Lego DeFi. Поэтому у них все мышление было построено как «We need more of the same». Понимаешь? То есть мы хотим больше этого EVM. Мы не хотим вот этого канального масштабирования. Мы не хотим быстрых переводов с безопасностью. Мы хотим именно вот этой вот хуйни, которая у нас заработала в Lego DeFi, мы хотим больше, чтобы она масштабировалась. Именно в этом виде, в котором есть. То есть, что контракты общались с контрактами. Они не мыслили за пределами Shared State. Поэтому они и создали ROLAPO как второй такой же CPU. А каналы – это GPU. Это отдельно существующие юниты, которые не связаны с друг с другом, и поэтому они масштабируются намного лучше. Или даже, я бы сказал, Penzer. CPU вот этот угловский. Знаешь? Да. То есть это CPU против TPU. Я тебе кидал эту картинку, там, кажется... TPU же не кидал, что ли? Этого там... Да, наверное... Слушай, да, меня иногда подзакрывает, когда я недоделиврил... Сейчас кому я скинул, кому я скинул, кому я скинул... Познакомился с еще одним очень умным, приятным типом. Пока строим отношения. У него химическая лаба. Он анализирует кокаин для тайских ментов. Вот, да. Был хороший? Не, не, ну, короче, ебануто крутой тип. Вот, короче, тут же вышел заголовок недавно, что DeepMind плотно работает над Navier Stokes, и вроде как близки к решению этой проблемы. Вот, меня... Ну, чем? Navier Stokes. Миллион долларов проблем. Это про... Не знаю, что это такое. Ой, слушай, посмотри, потому что меня подзакрыло, но, типа, это как-то слишком близко, типа, прям к сингулярности по определению, знаешь, не информационной сингулярности. Ну, напиши в чат, я потом, чтобы сейчас... Да, да, конечно, конечно. Я накидаю просто того, что я посмотрел на эту тему, и почему меня с этого начало подперекрывать. Вот, что, типа, у меня стало ощущение, что, типа... Короче, одна из теорий, почему мы не видим другие цивилизации в космосе, что они растут не вширь, а вниз. Понял? Типа, они уходят на... Энергоэффективность может уходить, типа, вниз по цепочке. То есть, как маленький саранск может иметь интеллект всей Земли, и мы его никогда не увидим. Не надо куда-то летать, он там... Типа, мы можем воспроизвести человечество в более миниатюрной форме. Понял? Ну, конечно, да. Нам такая большая Земля не нужна. Не нужна даже Земля. Ещё есть Россия. Да, да, да, да. И что, типа, космогология, она может... Ну, типа, я уверен, ты тоже временами трепуешь на тему того, как, блядь, всё нахуй работает. Этот вариант, когда просто, типа, мы не то что симуляция, мы просто очередная итерация более оптимизированной копии над множество, которое оптимизировалось и уменьшилось. И так раз за разом. Ну, тут я не совсем понимаю, конечно. Смотри, вот я насколько смог... Ну, я некомпетентен достаточно. Я скинул тебе, ну, собственно, заголовок. Про Naviestox ты сам посмотришь. И я сначала посмотрел объяснение чисто того, в чём заключается Naviestox. Я его тебе скинул последним, потому что больше мне помог разговор Лекса Фридмана с, блядь, как этого мозга зовут? Терен Стау. Вот. Он объяснял, как он работает над этой проблемой. Ну, это, короче, одна из проблем тысячелетия, как та, что Перельман решил. Но мне поплохело, потому что, как будто, если её решат... Ну, это, типа, проблема уровня ПНП. Ну, типа, если её решить и доказать, то, как будто, появляется возможность, типа, создавать сингулярность. Вот. Ну, блин. Да. Но, нет, я просто охуел с того, что, типа, DeepMind якобы близок к решению. Я такой, вы чё, вы чё нахуй? Вы куда, блядь? Вот. Но nothing ever happens, поэтому я охладил траханье и всё такое. Вот. Ты сейчас за компом или ты гуляешь где-то? Я дома. Так, смотри. Ну, тогда можно скриншар попробовать сделать сейчас. Так. Так мы же не закончили обсуждение. Да. Обсуждение чего именно? XLN же, правда? Ролапы, лайтнинг. Чем лучше, ты спросил. Чтобы... Не, я... Ну, пока что я... То есть, пока что ты рассказал мне ещё раз то же самое, что я от тебя уже слышал и понял. Надеюсь, мой словарный запас по объяснению этого другим людям, ну, хоть чуточку обогатился. Вот. Ну, то есть, я это интуитивно понимаю, сказать не могу. Но я тебе тезисы... Я каждый раз более лучшие тезисы подгоняю. Вот с ролапами я тебе объяснил, что тезисы основные — это bottleneck по масштабированию. То есть, с ролапами не решают проблему масштабирования. Это вообще не endgame даже близко. И, в принципе, не существует endgame, кроме системы каналов. Это математически невозможно. Потому что любые другие системы, они упираются вот в этот вот... в основной леджер. Если у тебя транзакция имеет хотя бы 4 байта, как в ролапах, там, сколько, 10 байтов импакта на основном леджере, или даже на валидаторах, как это в Bloopspace, всё, у тебя уже bottleneck. Единственная рабочая схема — это когда у тебя netting layer в виде каналов, когда совершенно никуда не публикуется транзакция, и ты между собой можешь гонять доллар миллион раз туда-сюда, каждую секунду. Тогда у тебя настоящий масштабируется. То есть, по сути, эволюция финансов, она к этому уже и пришла. Банковская сеть — это то уже, это совершенство уже. То есть hub-and-spoke, сеть банковская, она уже совершенна, но в ней есть системные уязвимости. И тут мы приходим к Lightning. Мой новый тезис в том, что Lightning Network в принципе не существовал. То есть нет такого понятия, как channel network. Почему? Я не помню, тебе говорил, Lego знаешь же вот эти кубики. Да. Соответственно, и представь Lego, которых с обоих сторон шипики. Так. А, типа не вставляется? Если я тебе дам мешок таких вот двухсторонних шипиков, ты назовешь это Lego-игрушкой? Метафора странная, но понятная, да. Не назовешь. Ты скажешь, хуйня какая-то. Это не складывается. И вот когда Lightning Network опубликовал свой whitepaper, они сделали именно это. Hydra и Raiden, они пытались создать сеть из вот этих вот двухсторонних шипиков каналов. Потому что это нельзя было рассматривать как рабочий вообще примитив для создания нетворка. То есть это на самом деле должна быть заговор не Lightning Network, а три security enhancement для системы аккаунтов банковских. Какие эти три enhancement? Первый enhancement – апгрейд. Это то, что у тебя банковский аккаунт не имеет аккаунт-пруфов. То есть у тебя сейчас открываешь любой банк, у тебя там ноль, и ты нихуя не докалешь. Мы создаем аккаунт-пруфы. То есть у тебя есть протокол по общению, когда вы обмениваетесь с банком любыми данными, в любой момент ты должен получить в конце аккаунт-пруф, подписанный сущностью банка, то есть его ханку. У тебя копятся вот эти ресепты. То есть ты, если банк исчезает, у тебя всегда есть бумажечка, где сказано, какого ассета, сколько, и подпись. Это первый уровень защиты. Потому что он защищает от такой атаки, как selective censorship. То есть банк не… Сейчас Coinbase может тебя лично забанить и послать нахуй какую-то, кому докажешь. А так ты идешь вот с этим ресептом в юрисдикцию и начинаешь дисплют. Но это не финал еще. То есть, да, это защита, но допустим, Coinbase решил всех кинуть и вывести там 10 миллиардов, и все пошли с ресепта. Теперь юрисдикция затребовала с резерва Coinbase сущности деньги, но там уже их нету, она уже все списала. Это уже второй уровень защиты. Это уже системные каунтерпатии риска. То есть что произошло с FTX? FTX, в принципе, первая проблема, она не так часто встречается, но ее вынуждено решить, потому что тогда нельзя будет решить вторую. Вторая решается с помощью collateral. То есть вместо того, чтобы у тебя все существовало в кредитах, как сейчас в банках, мы добавляем primitive lightning в виде collateral. То есть у тебя часть баланса, она обеспечена escrow каким-то вот этим резервом в юрисдикции, которое написано там между Алисой и Кабом 10 долларов залочено. И вот это второй уровень безопасности. Потому что теперь, если происходит диспют, даже если хаб уже все списал, все равно он не может забрать деньги из вот этого общего collateral. 50 Алиса получает гарантированно в случае диспюта. То есть account proof второй уровень это collateral, а какой третий уровень? Это субконтракты. То есть первые два уровня это security at rest, то есть у тебя гарантия, когда все спокойно, ты ничего не делаешь, то есть есть и proof, и есть collateral в юрисдикции. Но когда ты хочешь сделать какой-то перевод или swap, ты же вынужден обычно банкам или обменкам давать в custodial на время обмена. Соответственно, мы решаем это с помощью нового уровня DeFi, новых smart-контрактов, которые существуют эксклюзивно как эти GPU, как отдельные внутри каналов. То есть каждый канал такой микроблокчейн.

между двумя сущностями, и в них вы создаете такие подписки к вашему аккаунт-пруфам. То есть субконтракты существуют прямо внутри аккаунт-пруфа, которые говорят, если хэш такой-то зарелизен, то мы сдвигаем дельту на 100 до такого-то времени. То есть разного рода условия добавляются, и которые выполняются в исключительном случае диспютом в юрисдикции. И они гарантируют безопасность денег in motion, так сказать, в движении. И это закрывает полностью как бы и безопасность адреса, и безопасность движения. То есть вот эти три, в случае Lightning, это было HTLC, потому что у них только один субконтракт, так сказать, реализован, вот именно платеж. Hashtag-locked-contract. Просто они все это запаковали в одну хуйню и назвали, типа Lightning Network, и только так он должен работать. На самом деле это просто три отдельных примитива, которые надо было наслоить на банковскую сеть. Решив, по сути, основные банковские программы. Почему люди не любят банки? Потому что, а, они могут их просто кинуть, закрыть счет. Б, даже если у тебя есть receipt proof, они могут обанкротиться, все спиздить, вывезти за рубеж. И хоть ты претрись этим receipt proof, государство не может тебе напечатать счет или он. И C, это когда вот эти первые два решены, это уже, C можно в голову не брать, потому что это уже уровень, так сказать, повыше. Это именно security in motion, чтобы можно было деривативы, контракты, то есть на лету любые финансовые интеракции покрывать еще и гарантиями. Понимаешь? То есть, Lightningpress изобрел три security примитива, которые имеют смысл только как дополнение к существующей и уже идеальной банковской сети по масштабированию. То есть, мы берем банковскую сеть, которая уже сто лет работает, сотни лет, которая идеально масштабируется и накладываны в нее вот эти три счета. И все, и получается охуенно. Меня в байдизайн твои штуки беспокоят только B2C кейс, ну типа обычного Васила Пуха, который хочет пользоваться деньгами, ну типа, что ему как будто бы надо ранить ноду, вот. Но по идее просто можно... Ну, ранить ноду это техническая сторона, практически он просто скачивает из App Store кошелек lite какой-то, XLN Lite, который делает самый минимум, им просто надо ключи хранить и все, а все остальное визуально будет так же выглядеть, как работа с банком. Просто одно приложение на все банки. Ну, нет, одна система на все банки и то, что типа, ну типа, фуллноду нужно будет ранить, типа, Вася тогда доверяется просто некоторой фуллноде, с которой работает, но появляется возможность... Вариант один, он доверяет инфурии или какой-то фуллноде, которая держится юрисдикцией за него, и это происходит только из-за того, что сейчас фуллноды жирные, то есть Ethereum разожрался и поэтому его нельзя на телефоне сейчас, скорее всего, запустить. Но цель-то номер два, после того, как это запустится, запустить свой блокчейн, конечно, замену эфирма, который будет заточен именно под XLN, то есть у него будет зафиксировано там 10 транзакций в секунду, что он на любом телефоне может фуллноду держать. Соответственно, ты скачиваешь там гигабайт стейта, ну, короче, сейчас Ethereum номер 1 в центре, а надо создать такой же Ethereum, только channel-центрик, у которого задача будет это, быть максимально компактным, то есть чтобы он потреблял там 1 гигабайт данных, например, в день максимум, и фон его работал, синхронизировал переводы, settlement layer вот это в юрисдикции. Но это второй этап, потому что если зайти сразу с этого этапа, то в Ethereum вы такие, а вы не охуели тут параллельный чейн создавать, мы, короче, вам не пользоваться не будем. То есть надо сначала заявить, что это layer 2 для Ethereum, а потом пошли-ка вы нахуй, вы выбрали ралапы, ебаную технологию, которая не масштабируется, имеет просто зияющие дыры в безопасности, которые решить вообще никак уже нельзя, поэтому мы создаем свой чейн, так сказать, референс чейн. Но отказываться от Ethereum тоже смысла нет, поэтому это мультиюрисдикционная сеть, она может поддерживать и Ethereum, и Solana, и Ethereum Classic, то есть ты просто выбираешь, на какой юрисдикции создаешь сущности, в ней ты работаешь, то есть это unified layer 2. Вот, еще меня волновал вопрос того, что потеря данных приводит к потере денег. Верно. Вот. Но не то, чтобы гарантированно, ты можешь по-милому попросить вторую сущность, с кем работаешь, дай-ка последнее состояние наших аккаунтов, но если она решит, по-плохому действовать не даст, то ничего не сделаешь. Ну надо бэкапить. То есть тут ты сам себе бэкапишь, а в случае, смотри, тут ты как бы и можешь сам бэкапить, и можешь доверять контрпартии в виде хаба, а в случае ролапов ты не можешь сам бэкапить, ты по определению только доверяешь состоянию, что они его хранят. Ну, нет, там как бы чуть сложнее, они все-таки его публикуют, нет, пожалуй, сравнение неправильное, они публикуют его он-чейн, и кто-то, может быть, пока еще ТПС маленький, еще и держит. То есть я не отрицаю, что сейчас, наверное, у бейса есть кто за ним перепроверяет, пока ТПС маленький. Да. То есть кто-то пытается создать скейлабилити хотя бы на Таиланд, на 80 миллионов человек, а это уже будет сотни тысяч ТПС, и вот тогда-то мы и поговорим. То есть любое скейлабилити решение надо рассматривать не как оно сейчас работает. Сейчас я могу, скорее всего, бейсноду поддерживать на ноутбуке, наверное. А как оно будет работать типа фуллблоу, как бы финальная его версия. То есть в финальной версии XLN, когда у него будет майонет-релиз, вот как он зарелизен, он также может замасштабироваться на миллион транзакций в секунду по определению. Потому что там нечему растягиваться, нечему ломаться. У тебя хаб достигает какого-то предела, ты просто запускаешь новый хаб. Это даже хорошо, что это будет на TypeScript и не сильно масштабируется, потому что если это будет слишком масштабируется, то будут жирные хабы, которые too big to fail, понимаешь? То есть лучше иметь много хабов, которых по небольшому количеству юзеров, которые если один сломается, остальные типа обходят его, чем иметь два хаба, где один сломается и все, вся сеть встала. И все люди недовольны. То есть это даже не бака фича, что хабы должны иметь какие-то базовые ограничения масштабируемости. Вот. И тогда смотри, если есть кайф, можно просто пробежаться бегло по хуйне, написанной без нейробрейнрота. Я просто пытался то, что мы в прошлый раз проговорили, написать ручками. Можно писать с ИИ, но это должно быть типа любой код, который попадает в комит, он должен быть проверен тобой, типа я с ним согласен, а не типа пиши. Конечно, конечно. Не, бро, я понимаю, о чем ты говоришь, чтобы ты не думал, что я идиот, который пытается типа скормить просто наши разговоры в нейронку и получить правильный ответ. Я это использовал для того, чтобы меньше заебывать тебя вопросами, генерировать... Не, вот тут вообще ты не прав, нет такого понятия заебывать меня вопросами. Вот ты видишь, я как бы разговариваю, я могу отвечать бесконечно хоть... Класс. Мне нравится отвечать на вопросы, нет такого понятия заебывать вопросами. Класс, ну... Наоборот, любой вопрос, который у тебя минимально возникает, и ты думаешь, что я теоретически могу узнать ответ, просто, блядь, в чьем-нибудь формате. Вот, ну и короче, эта штука мне помогла типа сформировать понимание многих штук, включая там типа как стоит машина, оформлять хорошо. Вот, я в итоге там в один момент упоролся, ушел в такое типа ха-скиль уровневое программирование, просто ради интереса посмотреть, а как бы оно было. Оно на самом деле прикольно, потому что ну типа оно все строится на супер типа доказательствах, на доказательствах. Скорее всего, идеальная версия такая, которая... Цель-то, чтобы это на уровне правительства типа работало. Идеальная версия была бы типа ха-скиль нода, которая прямо математически доказанная, формал-пруф, математиками, чтобы прямо уже это и на триллионы, так сказать, масштабировалось. И все, и можно было бы расслабить булки. Потому что TypeScript, я уверен, дыра какая-нибудь... Да, дыра, конечно. Оптимально by design нам Elixir, который функциональный и построен поверх Erlang. И он там в плане процессов и прочих штук, он прям, ну, созвучен очень с тем, ну, как дизайнится система. Но пока TypeScript идеален для того, чтобы... Да, TypeScript это английский сейчас. Это выразительный язык, да, да, да. Согласен, согласен. То есть, чтобы заинтересованный чувак с Hacker News мог открыть, опа, тут, я думаю, версия должна занимать не больше, там, десяти тысяч треххода суммарно, ядро. И типа просто за час прочитать за два и типа понять. Когда человек понимает, как что-то работает, все, он в это поверит. Там эти, там верификации, они немножко начинают раздувать код. Ну, то есть, типа все проверки всех условий на то, что все можно сделать так, как хочется сделать. Да, новые ноды же никто не запрещает в любых языках писать. Конечно, да, да, да, это я безусловно понимаю. Просто это референс. Вот. Я вот дошел как бы к гидра, который у кардана открываешь, там, Haskell, еще я ничего не пойму. Я могу его только скормить в LN-ку и спросить, что он делает. Ну, вот LN-ка мне сказала, что ничего отличающего от Lightning она не делает. У них там тоже хэды, они называются каналы типа хэды. Типа ты из мейнчейна создаешь хэды, и уже они продолжают отдельно работать. Ну, как бы, да, каждый канал — это как бы продолжение юрисдикции, то есть ты просто, не касаясь юрисдикции, передвигаешь аллокации ассетов, но фундаментально это очень важно понимать, что ни один Layer 2 не может существовать без кредитов. И вот все остальные в крипте, они ссутся от этого слова «пиздец как». То есть, смотри, раллапы используют кредиты, я тебе это уже говорил, помнишь, почему? Ты говорил, я не помню, почему они используют. То есть любой функциональный Layer 2 математически не может существовать без кредитов. Это очень важный тезис, запомни его. Почему? Потому что, представь, смотри, есть некая сущность, хап, сиквенсер, как угодно может называться. Это может быть одна нода, может быть сто нод, которые имеет внутренний консенсус Entity. И здесь некий получатель, который получает ассеты. Наша цель, чтобы он получил это за subsecond, то есть instant, каким-то переводом от отправителя, от Алиса. То есть Боб должен получить платеж без прикоммитмента в юрисдикции, то есть как в случае с лайтингом. В чем проблема? Что хап должен прикоммитить заранее, зафандить ассеты в канал, вот эту искру между собой и Бобом. Понятно звучит? Да. Этой хуйней не работает, это уже доказано. То есть лайтинг – мертвая хуйня, райден умер в момент запуска, там просто 420 долларов капитализации на анченне. И гидру ждет то же самое. И там еще десяток сейт-чанел кай-райдов, которые тоже не заработали. Просто потому что проблема last mile delivery, она не решается без кредита. Соответственно, если коллапорум нельзя закладывать, то у тебя единственное решение для инстант платежа – это кредит. Почему? Потому что представь, любого рода эта сущность генерирует байты и отдает Бобу. Кто мешает ее генерировать такие же байты и отдать еще тысячу таких Бобов на ту же сумму? Если нет прикоммитмента в юрисдикции. То есть по определению, любая форма взаимодействия будет иметь с собой форму кредита. То есть это будет каунтерпати-риск. То есть невозможно без риска доверия вот этой сущности хаба Бобу принять. Потому что коммитмента заранее существующего в юрисдикции не существует. То есть Lightning решает эту проблему тем, что ты делаешь коммитмент, но у него слишком жесткие требования к безопасности, поэтому он не масштабируется за пределами платежей за телефон и десятку энтузиастов, которые уже залочили деньги между собой и гоняют по доллару с удачи. А как ты видишь... Да, скажи, закончим мы сегодня. Да, то есть для роста по математичке нужен кредит. Это не трейд-офф, это не вот мы временно используем. Это просто по самой топологии, если ты хочешь на лейере 2 сделать моментальный, а моментальный это обязательно, это не обсуждается. То есть никому не нужна сеть, где будет 10 минут подтверждения или там минуту даже. То есть по определению все упирается в кредит. Соответственно, roll-up, они же работают, они же делают моментальные переводы, да. Как они это делают без кредитов? Они используют кредит, просто они это называют по-другому, это называется pre-confirmation. То есть pre-confirmation это roll-up говорит секвенсер хапа, он говорит Бобу, я тебе сейчас пришлю транзакцию, вот, честно-честно. То есть он делает то же самое, что делает хап в XLN, он говорит обещание. Это кредит, просто другое название. То есть математически лейер 2 не может функционировать без кредитов. Кредиты это просто necessity. И любая лэмка с этим согласится. Ну, лэмки много с чем соглашаются. Лэмки, к сожалению, много с чем соглашаются, но я понимаю. Да, это я готов поставить, типа, open argument с любым человеком, который, типа, с XLN также будет свои тезисы скармливать, так сказать. Ее же можно с обоих сторон, что называется, стереть, направлять. То есть я своими тезисами разгибу просто. То есть невозможно создать архитектуру, где ты, вот эта хаповая сущность, делает моментальный перевод Бобу такой, чтобы Боб иметь 100% гарантию, что он эти деньги получит. Потому что по определению этих Бобов может быть миллион, которому вот этот хап делает точно такой же набор байтов, как ты генерирует. Так. То есть ее никто не мешает именно double spend вот это сделать. Потому что проблема double spend решается либо кредитом, либо pre-commitment. Другого решения быть не можно. И pre-commitment это что? И pre-commitment не информируется, как у Lightning. То есть либо хап заранее идет в юридикцию, говорит всем вообще в сети, я закладываю 100 баксов в сторону Боба, чтобы потом уже Бобу приватно сказать, вот тебе аккаунт proof, где ты владеешь из этих 100 баксов 50. Понимаешь? Либо он может только пообещать. Все, третьего решения тут не может быть. Вот. Либо кредит, либо pre-commitment. Pre-commitment это collateral или нет? Или что это? Да, да. Это одно и то же. Ну я понимаю, я просто проверяю, что типа я правильно понял. Вот. Так, дай я сейчас гляну, что я там дошел. А, ну собственно я сделал, чтобы мы согласовали, ну я накидал скетч того, чтобы все подписались над блогом. Кстати, тупой вопрос, прости за него, я мог бы его и ссылать. Нет тупых вопросов. Спасибо, брат. Значит, короче, блог хайт, почему мы его всегда храним? Он фундаментально важен, я понимаю, нет интуиции, почему он фундаментально важен. Ну просто, чтобы был. Ну, хорошо, а что будет, если мы его не будем хранить? В чем проблема? Визуально непонятно, сколько блогов произошло. Лишним не будет, я не знаю, лишним не будет, пока от него ничего не зависит. Типа сложнее найти просто. И смотря на каком уровне, там же три уровня машины, то есть на уровне сервера блог хайт совсем особо на ничего не влияет. Да, нет, на энтити. На энтити блог хайт, то есть каждая из этих машин, она хранит и блог хайт, и таймштамп того, когда последний. Я, кстати, еще предлагаю заменить слово блог, потому что блог часто ассоциируется с юрисдикционной машиной, с большими, толстыми и редкими блогами на слово frame. То есть как снапшот-система такой, фрейм, фрейм, фрейм, потому что фрейм ассоциируется с чем-то быстрым, а фреймы у энтити могут идти, например, 10 миллисекунд. Фрейм нравится слово, я постараюсь покрутить его, чтобы вошло в обиход. Фрейм – крутое слово, мне нравится. Типа, когда работает юрисдикция и говорим блог, по-стареньки, чтобы здоровье данной модели пускай поживет, фреймы – это сервера, внутренних энтити, внутренних аккаунты, у них у всех фреймы. И у каждого фрейма есть высота и таймштамп. Так, подожди, а может быть у энтити фреймы, а у сервера блог? Ну, типа, похуй, что… Ну, короче… Не-не-не, потому что блог – это значит медленно, и это значит связано с юрисдикцией ментально. То есть вот эти… А у сервера тик, братан, у сервера тик? Ну, тик как бы тоже не в тему, потому что вот эти три машины, они плюс-минус одинаково работают, поэтому серверные фреймы – это все, что приходит в энтити. Энтити фреймы – это все, что приходит… Точнее, инпуты, которые приходят в энтити. А энтити фреймы – это все, что внутри нее происходит и приходит в аккаунты уже. А аккаунт фреймы содержит наборы транзакций, которые именно между двумя сущностями происходят, там, создание субконтрактов и так далее. Ну, короче, фрейм – крутое слово, согласен, да. Согласен, окей, согласен. Фрейм – хорошее слово. И каждый фрейм на каждом из этих трех уровней имеет и хайт, и таймштамп. А почему важен таймштамп? Ну, просто чтобы был. Хорошо. Наверное, можно и отказаться, но просто пока… Но это не редандансы. Вот такие штучки меня чуть-чуть в легосе-коде путают. То есть да, я вижу таймштамп, но фундаментально типа на ассембле… Считай, что для отладки. Чтобы видеть визуально, что когда происходит, хотя бы, как консоль-блок. Можно в будущем понадобиться. Ну, как бы таймштампы точно нужны уже на уровне субконтрактов, потому что от этого строятся там все таймауты, дилеи, вот это все. Я вот думаю, что это все вот такого рода поля нужно, наверное, куда-нибудь в мета объединять, что мета – это какая-то информация, которая типа… Фрейм – это и есть как мета. Это два основных заголовка фрейма, которые у всех одинаковые. Высота, номер фрейма, первый, второй, третий, и таймштамп. Плюс 10 миллисекунд, плюс 5 миллисекунд и так далее. А все остальное уже машинспецифик. Типа на уровне сервера у тебя набор инпутов в Entity и состояние всех Entity. Можно их, кстати, размотать. Можно, если не нравится… Да, можно размотать их в один слой. То есть держать… Помнишь, мы говорили массив массивов? Можно это держать просто одним массивом. Просто массив реплик. Можно назвать вот эти вещи, которые хранит сервер, репликами, чтобы, опять-таки, упростить метальную модель. Потому что раньше мы это называли как? Сущности. А ведь если это одна сущность, ABC, и она хранится от трех сайдеров, и у A, и B, и C… То это реплики, да. То немножко сложно понимать, что это три разных реплики одной и той же сущности. Поэтому проще назвать, наверное, реплики. Так нет, все так и есть. Ну, короче, я посмотрю, где это в коде можно использовать, но я уже к этому сам привык, что Entity – это принципиальная штука, а реплика – это то, что лежит конкретно на машинке у каждого сайнера. Его видение того, в каком состоянии сейчас находится Entity. Да, его текущая машинка, связанная с этим workspace. То есть Entity – это еще и чат. Одно из самых простых вещей, которые не требуют пропозывов. То есть, когда ты хочешь написать чат-сообщение, оно же не влияет на состояние. Точнее, оно не влияет на какие-то внешние действия Entity, оно влияет на состояние. Так вот, как будет работать чат? Это вот самый базовый use case у Entity, даже до пропозывов. Это просто ты пишешь чат-транзишн,

И он делает пуш ко встроенному точка стейт, точка чат массив. Я понимаю. И все, и просто жирно растет стейт. Все так, но он должен пройти через весь цикл про паузу блока и закоммититься, то есть сообщение, оно попадает… Да. Любые изменения стейта должны пройти через фрейм, через консенсус фрейма. Ну, это, конечно, огонь. Ну, просто, да, я увлекся тем, что мы в чате разгоняли, чтобы у нас еще был… То есть, у нас есть блок-пропозал, это как, ну, собственно, понятно. И обычный пропозал – это когда, чтобы… Действие от лица сущности. Да-да-да, вот. Теперь смотри, пока я писал ручками и своей головой вытаскивая, у меня такая терминология сложилась, если что, поправь. Я назвал словом «месседж», это вот то, что у тебя был там аутбокс, это то, что завернуто и роутится. То есть, «месседж», он имеет from, от кого, ну, типа, на всякий случай, кто, кто, блядь, вообще это послал. И самое важное – куда. Куда оно в первую очередь идет в entity address и может быть уточнен, собственно, сайнер. То есть… Всегда должен быть уточнен, потому что просто entity address – это, ну, слишком абстрактно. Смотри, да, да, мы можем не знать в некоторых случаях, кто сейчас блок-пропозер. И мы можем написать… Ну, у нас он статический, на данный момент мы знаем все. Да. Просто, как бы, мы читаем на ритору. На данный момент. Я, ну, но в целом… Я понял. Ты имеешь в виду, когда round robin пропозер. Да. Когда мы хотим, нам похуй, кто там из сайнеров вообще что решает. Мы можем написать в entity, типа, чуваки, дайте нам денег, ну, грубо говоря. А оно уже… Но когда ты пишешь в entity, ты все должен знать, кому ты отправляешь. То есть, в реальности это много разных серверов на разных URI. Потому что ID сервера – это просто его URI с портом. 127.001.3002, например. Это вот ID сервера. То есть, ты должен знать, к какому сайнеру ты хочешь послать. Ты не можешь послать entity, не зная, к какому сайнеру. Поэтому, по определению, на момент посылки ты должен вычислить его пропозера актуального. И поэтому, по определению, месседж должен иметь указание. Так, подожди. Я жестко спорить не буду, потому что ты босс, но выслушай вариант. Что если сайнер не указан, мы говорим, что мы отправляем письмо в данную компанию. Когда оно приходит, ну, грубо говоря, все чуваки, которые знают об этой entity, они его видят, но… Подожди, подожди. А кто видит? Где они видят? То есть, письмо-то должно быть отправлено, в конце тика оно должно быть добавлено в мейн-пул сервера. И сервер уже разроутит, кому оно предназначается. Так это сейчас все в одной симуляции. А ты представь, когда реальность… Каждый сервер в реальности будет иметь одного сайнера только. Соответственно, тебе уже надо понимать на момент отправки в Outbox, к какому серверу ты это пошлешь. Сейчас сервер один, и поэтому понятно, что ты пошлешь самому себе, к какому сайнеру, так сказать. Но надо не забывать, как это потом будет. Я просто про то, что… А, сейчас, подожди. Я просто подумаю, что нет такого… Мне надо сейчас секунду подумать и понять, что нет такого случая, когда мы не знаем, собственно, кому мы шлем. Ну да. Мы в любой момент времени, когда мы месседж в Outbox создаем, мы просто смотрим, кто у них сейчас актуальный пропозер, и его же ставим получать. Потому что нельзя отправить прям Entity просто в никуда. У Entity всегда есть представитель актуальный. Его реальная входная точка, которая собирает уже блоки и сообщает остальным… Я просто про то, что если реплики рассинхронились, если вдруг наша реплика ошиблась в том, кто сейчас реальный пропозер. У другой реплики, у другой Entity. Да. Не, не… Сейчас, дай подумаю. Даже у себя одна и та же Entity, но разные сервера. Я думал, что пропозер ты, а на самом деле пропозер Арсений. Я тебе послал сообщение, а оно на хуй ушло. Ну да, наверное, оно отвалится тогда. Это можно, кстати, легко решить. Ты можешь по определению, когда ты хочешь послать сообщение пропозеру, добавлять его в локальный mempool. Это как бы мы предложили, но оно еще не подтвердилось. А когда ты не пропозер, локальный mempool тебе поддержать как… То, что мы хотим добавить. И если оно не подтверждается какое-то время, то продолжать пинговать текущего пропозера. То есть рано или поздно оно дойдет. Короче, я понял. Резолвить получателя обязательно должен отправитель. Круто. Ну да. Все, услышали. Потому что Entity, она сейчас, она вся живет, все вообще живет в одном сервере, но в реальности Entity разбросан на трех разных серверах у трех разных сайнеров. И каждый из них пропозер по определению. И тебе надо знать, кому именно посылать. Потому что если ты посылаешь не пропозеру, он не может создать блок, он не может твою транзакцию запекать в текущий state-changing блок, так сказать. Потому что представитель, главный пропозер, он создает блок. И для простоты у нас это всегда будет статично. А потом он будет ротироваться. Огонь. Потому что сущность, она как совет директоров. Ты же не ротируешь SEO каждый день. Да. Тут, кстати, еще очень прикольная новая, так сказать, метафора. Знаешь, в нетворкинге есть Broadcast, Multicast и Unicast. Вот не знаю, что такое Unicast. Ну вот Unicast это, короче, Broadcast это от одного вообще всем. Мультикаст от одного группе, типа от одного, например, 5. А Unicast это от одного к одному. То есть она трехмерно соединена. И вот тут идеально как бы оно мапится на GM модель. Сущность это Broadcast. Сущность это Multicast. Либо если это Single Signer Entity, то это сразу моментальные фреймы. И канал, аккаунт, это Unicast. То есть тут, получается, система состоит из трех основных видов взаимодействия нетворкинга. То есть просто математически все три структуры используются. Огонь. Огонь. Смотри. Так, тогда возвращаемся. Собственно, Message – это вот то, что мы шлем пока что. Смотри, почему есть сомнение называть это Месседжем? Потому что любой Месседж – это же, по сути, транзакция. То есть то, в каком виде она приходит уже, это уже рассматривается как транзакция, которая… Нет, смотри. Транзакция не имеет получателя и отправителя. Транзакция – она просто транзакция. А Месседж, он прикольный тем, что ты его в конвертик положил, и он кому-то адресован. На первом уровне, значит, самое главное, на вход в сервер, это ты адресуешь сайнеру и эндите, чтобы понять, в какую реплику это попадет. Да. То есть реплика адресируется сайнером и эндите. И это можно назвать импутом, как мы это называли. То есть это скорее подходящее слово. Почему импут? Почему ты его назвал импутом? Потому что это каждый серверный тик, импут – это набор всего, что попадает в сущность. Мемпул. Смотри, вот. Я просто думал, что Месседж – это то, что прилетело условно в мемпул сервера. Не совсем, не в мемпул. Это набор действий, которые применяются к реплике. То есть это транзакция, консенсусного уровня, более высокого уровня. Смотри, я понял, что ты называешь импут. Я переписывал, ты можешь меня поправить. У меня получилось слово «команд». Я понял. Некоторая команда, которую мы говорим, исполнить на уровне импута. Мне кажется, импут… Да, same, same. Команда утверждает, сделай это. Да. А импут – это просто… Я предлагаю, знаешь, объединить все в один импут. То есть каждый серверный тик, один жирный импут, просто один вызов функции applyInput, в него попадает вот этот ROP заинкоденный импут, у которого просто через запятую идут все виды… Импутов, импутов. Команд, братан. Импут – это вся хуйня, а команда – это каждая отдельная фразочка. Ну, тебе два слова надо. Одно – объединение вот этих команд. Да, это импут. И второе – каждая отдельная. Команда. То есть добавить транзакцию, генезис, точнее импорт… Да, да. Импортнуть, добавить транзакцию и концепция вот этих переводов. А вот подожди, подожди, импортнуть, оно к кому прилетает? Кто являет, то есть вот… Сервер выполняет импорт entity, то есть она из воздуха создается, у него стоит… Ага, сейчас, подожди, я думаю, думаю, думаю, у него создается entity… То есть в серверном фрейме содержится вот этот… Для того, чтобы создалась entity, у нее уже должен быть сайнер. А сайнеры, они не то, что существуют, это просто ID-шка, индекс ключа, который используется для именно взаимодействия с этой репликой. То есть сервер на лету берет, если там 47-й сайнер, даже если его ни в каком виде еще не испытывался, просто берет из своей ключицы 47-й сайнер, 47-й приватный ключ. Ух ты. То есть их не надо как-то отдельно регистрировать. Ух ты, сейчас, подожди, думаю, думаю, думаю. То есть сейчас… При запуске сервера ты генеришь в памяти там 20 ключей. Ну, условно, да, сайнер, да, да, да. Ага. Я… И, соответственно, к серверу прилетает первый вот этот вот input, который говорит импортируй сайнер 0, entity ID ABC и стейт всей, точнее не стейт, а текущий фрейм entity закодированный. И сервер это во время тика запускает в свой фрейм, в input, и у него создается новая ячейка в стейте этого сервера, то есть новая реплика. Слушай, вот это сейчас интересно стало, давай разбираться. Значит, прилетело… Ну, я все еще буду пока цепляться за сообщение. То есть в состоянии сервера, когда у него 0 реплик, пустой массив, как появляется первая реплика? Вот к нему прилетает этот input, и он добавляет его в свой первый фрейм. И, соответственно, стейт сервера дополняется теперь одной репликой. Вот смотри, да, да, да, я понимаю, прилетел input, а у input какие поля? Input не может знать, что это за entity… Ух ты, подожди, сейчас я это записывать уже буду, это важно. Значит, некоторый там const input, пускай будет так, равно… Он утверждает, я хочу твоему такому-то сайнеру… Вот, откуда он знает сайнера? Откуда input знает сайнера? Не думай об этом, просто представь, что это какой-то shared db, то есть у тебя просто в консоли напечатано, данный сервер поддерживает 20 сайнеров, просто через запятую… Нет, я про то, что ты сейчас хочешь создать реплику, ну типа import entity сделать, откуда тебе знать, почему внешний чувак, который этот input отправил, он знает сайнера, потому что это… Не думай об этом, просто представь, что все это открытая публичная доска, которая просто напечатана, и ты копируешь из этого симуляцию. В будущем это будет, ну типа я хочу с тобой создать entity, я из своей доски копирую моих сайнеров, моего сервера нулевого, и говорю, вот, можно с моим нулевым сайнером создать, и допустим, вот этот профайл, помнишь gossip профайлы, я просто там заявляю, что вот этот вот сайнер живет на таком-то сервере. Ты, добавляя его при создании entity в форум, у тебя резолвится, ты узнаешь, какой у меня сервер, URI порт, потому что из публичных профайлов это видно, и на мой компьютер прилетает запрос от тебя, импортирую к entity, и там можно будет создать систему подтверждения, но сейчас ее не надо, просто автоматически, если мне прилетело, я ее сразу импортирую. Вау, вот смотри, сейчас мы коснулись того, чего у меня в голове еще не было. Вот это самое ядро, самое, как сказать, из чего появляются первые entity. То есть, условно говоря, input'ом является, ну там, команда, отправленная в консоль. Ну, типа того, да. А это и из веб-сокета, и из консоли. Да, ну, понятно, да. Да, я понимаю, что условно это... И input'ом именно entity мы говорим. То есть... Input'ом entity? Мы сейчас... Мы присылаем на сервер input entity. Input сервера мы не будем объявлять как-то отдельно, потому что, ну, пропустим... Смотри, смотри, смотри, вот давай прям самое-самое начало. У нас есть некоторый пустой сервер. Да, пустой массив entity. Пустой массив, да. Пустой массив реплик. У нас есть пустой сервер. У нас у него есть какой-то рутовый ключ, от которого мы можем нанять сайнеров, это неважно. И они сразу в консоли написаны. То есть, ты запускаешь, у тебя в консоли ноль, двоеточие, такой-то публичный ключ или приватный ключ. Так уже сейчас работает hard-hat, например, когда ты запускаешь... А тебе не видно? Я вроде экран шарил, тебе не видно? А я в теннис играю на столе. А, хорошо. Хорошо. Значит, тогда... Сейчас, подожди. Так, ага, значит, пускай будет const... Сейчас телефон открою. Да не парься, я пока... Я скажу, когда смотреть. У нас есть сервер, и самый пустой сервер, это у него есть, типа, рут... Что это? Ключ, типа, рутки. Как называть рутки правильно? Секрет. Секрет, окей. Да, секрет, да, у него есть секрет. 32 байта, из которого строятся все его секретные действия. И приватные ключи, и randomness. 32 байта... Random string, или что это? Да. А в данном случае, не надо его каждый раз генерировать, это просто можно записать как ноль-ноль-ноль. Соответственно, при запуске разного рода сценария можно просто менять этот секрет, и у тебя получатся разные, как сказать, эмуляции. Да, эта зараза почему-то мне делает ноль икс, а я пытаюсь просто... Нам нужна рандомная строка на три... Окей. Сейчас воспользуюсь все-таки подлым и... Generate random 32-байта string... Нет, не код напиши, но... The code... String itself... Хотя можно было взять и исполнить. Ух ты, задумался. Все, огонь. Вот, сгенерилась рандомная строка. Из нее получается тогда signers... Я закомментирую сначала. Signers are array of... Есть какое-то сокращение для private-public? Типа какое-то устойчивое выражение, что эта пара private-public? Папки, привки... По сути, это просто signer равно... Пап-прив, да. Вот, и теперь еще вопрос. У сайнера адрес будет или нет? Или это просто пап-прив? Адрес он же derives из public, да? Да, да. Адрес это, конечно, от публичного ключа. Плюс... Первые 20 байтов. Адрес... Это в коде даже писать не надо. Даже либо какие-то притаскивать. То есть, просто представь, что у тебя сайнеры 0, 1, 2, 3. То есть, сигнатуры нам тоже сейчас не нужны. Я на всякий случай... Вот я, чтобы различать, я это сейчас в комменты начал писать. Теперь смотрим. У нас есть сайнеры. Это массив, бла-бла-бла. И, соответственно, массив это просто индексы. А вот тут интересно. Мы сайнеров храним по номерам, типа индекс, или по адресам? Ну, это все на лету можно. Можно создать обратную реверс. Да, понятно, что нужно будет. То есть, смотри, тебе в сервер, если в реальности будет приходить, понятное дело, по адресам. То есть, глупо говорить, типа у меня седьмой сайнер. Тем более в реальности, как правило, только нулевой сайнер ты будешь пользоваться. Нет смысла в реальности от своего сервера использовать больше, чем нулевой сайнер. Потому что они все все равно из одного секрета. То есть, если у тебя взломают сервер, они все сайнеры автоматически взломаются. Мы делаем много сайнеровый сервер только для симуляции, только для различных реплик. А в реальности просто будет один нулевой сайнер, которым ты будешь пользоваться, чтобы дать его другим серверам, так сказать, для создания энтити вместе, если это понадобится. Либо из него уже создаешь энтити, сингл сайнер энтити, так сказать, свою. Ты ей уже взаимодействуешь. Взаимодействуешь. Derived from pubkey, created from secret, да? То есть массив сайнеров он создается из секрета? Да. Так, signers это array. Вот. А что ты мне нахуярил тут? Прости потупливо. Собственно, одним сайнером будет являться что private, public, key, address. Окей, давай допустим. В нашем случае пока просто число. То есть просто число, а потом это адрес. Эфировский адрес 0x... Знаешь, как можно забавно сделать? Я это сейчас пока опишу не как массив, а как объект, но в нем индекса. Ну, короче, ключом будет индекс. Так уже есть. Это массив ключей индекса. Ты просто бушишь адреса, и у тебя получается нулевой такой-то адрес. Да, я про то, что я это в синтаксе с TypeScript записываю как объект, у которого ключом является индекс.