Собственно, одним сайнером будет являться, что private key, public key, address, ну окей, давай, допустим, прием. В нашем случае пока просто число, то есть, просто число, а потом это адрес, эфировский адрес, 0x, чуть-чуть, что-то там, 20. Да, знаешь, как можно забавно сделать? Я это сейчас пока опишу не как массив, а как объект, но в нем индекса, ну короче, ключом будет индекс. Так уже есть, это массивных ключей индекса. Просто бушишь адреса, и у тебя получается нулевой такой-то адрес. Да, я про то, что я это в синтаксе TypeScript записываю как объект, у которого ключом является индекс. Вот, так, прикольно, значит, есть private key, public key, address, бла-бла-бла, окей, есть сайнеры, заебал. Теперь, значит, ну на самом деле понятно, что их в явном виде типа как бы описывать не надо, потому что они не устраиваются из секрета, это типа более или менее понятно. Так, значит, и сейчас у нас entities, они пустые. Это даже entity-replicas, да. Нет реплик никаких еще, сервер девственный. Это понятно, я про то, что, я о том, что entity-replicas, давай я коммент напишу. А прям так, entity-replicas, два слова, можно каждый раз вначале писать название машины, а второй под вид. Либо реплика, либо фрейм, либо стейт. То есть, такие три уровня основные у машины. Реплика – это главная входящая точка. Я сейчас говорю о том, что у нас есть сервер, и у него есть entity-replicas. Да, массив. Репликас. Массив, говоришь, да? Опять же, сейчас массив, а почему массив? Они индексированы, но у них будут адреса, да? Ну, просто реплика. Ты каждый раз, когда хочешь какую-то реплику найти, ты делаешь find по этому массиву и сверяешь сайнер-ид и entity-ид, и когда есть совпадение, возвращаешь. Сайнер-ид. Точка find, по-моему, в JS называется. По массиву. Так, смотри, я сейчас делаю немножко втупенькую тоже, как с сайнерами. Значит, entity-replicas – это объект, где ключом является индекс, там, ноль, нулевая реплика. Индекс реплики, да. Но он не важен, то есть, ты не можешь послать какой-то индексу реплики, ты послаешь сюда конкретному сайнеру и конкретному entity-ид. И, соответственно, логика сервера – это сделать поиск итераций по массиву реплик. Сейчас, смотри. И найти, где оба значения совпадают. Смотри, тут что получается, что entity-replicas у нас есть вот нулевая, и у нее есть что? У нее есть адрес, правильно? А, ну вот ID-шник. Вот тут интересно, индекс реплики, индекс реплики и ID-шник entity – это разные вещи абсолютно. Да, да. Индекс реплики, в принципе, не важен. А адрес entity и ID-шник entity – это разные вещи? Вообще, да. А почему? Потому что ID-шник реплики… Это типа… Фу, фу, подожди. Нет, ID-шник entity – это то, с каким номером она хранится в entity-провайдере. Типа… Либо это как нейм-сервис, либо это хэш-кворума. Адрес – это уже более конкретно, типа, какая у тебя юрисдикция плюс название контракта entity-провайдера, плюс уже entity-ID-шка. Ого, подожди. Понятно? Да, смотри, понятно, но просто у меня слово «адрес» по умолчанию всегда ассоциируется с эфировским адресом. А это, по сути, есть как эфировский адрес? То есть, для того, чтобы послать деньги, ты будешь говорить кому-то свой entity-адрес? Хорошо, тогда делаем так. Подписываем, что такое ID. ID из… ID – это именно та ID-шка, с которой ты хранишься в entity-провайдере, а адрес – это уже полное… Можно даже, знаешь, не хешировать, а просто сказать, это конкретизация, допустим. Chain ID, потом entity-провайдер. Да-да-да. ID of the entity in entity-provider. Так. И тут ID-шники какие будут? Просто цифровые, строковые? Да, строковые, наверное, да? 32 байта? Можно, да, можно цифровые, типа 1, 2, 3 и так далее пока оставить. И потом сделать как этериумский нейм-сервис, чтобы по слову, нихнейму. Ага, 32 байта. 32 байта, необязательная стринг, просто 32 байта. Так, есть… Да, дальше. Дальше, адрес. Адрес у entity… Напомню, entity-адрес у нас из чего конкретинируется? Ну, так сказать, более полный адрес. Я… Юрисдикция, потом entity-провайдер внутри юрисдикции, это контракт, адрес, плюс вот эта ID-шка. Плюс entity-ID. Ага, и вот смотри, он конкретинируется или… То есть это как e-mail, смотри, хомаков, gmail.com. Хомаков – это entity-ID, gmail – это название entity-провайдера, ну, по факту gmail – это адресификатор. Да, согласен. А .com – это юрисдикция. Вот, это круто звучит. Вообще, как будто можно такую нотацию использовать. Да, да, вполне. То есть хомаков, собака, xln.xln, xln.f, например. То есть это значит основной entity-провайдер на точку эфира. Но кто-то, если зарелизил другой entity-провайдер, то это же extensible часть, можно другую логику зарелизить там и назвать его по-другому. Так, тогда берем, тогда ID может быть словом, пускай будет там, ну, Alice, наверное, тогда, да? Alice – это ID, entity. Адрес у нас, получается, Alice, собака. Это как бы как в идеале, но на данном этапе можно все упростить и сказать, что entity-адрес равен entity-ID. И просто константы всегда одна юрисдикция, и всегда одна типа один entity-провайдер. Да, упростить можно. У меня сейчас хорошее состояние, когда я улавливаю общее видение. Почему бы, ну, типа сократить легко. Alice, значит, адрес в целом – это Alice, собака, потом идет у нас entity-провайдер. Entity-провайдер – это некоторый контракт внутри юрисдикшена, правильно? Вот. Кто может быть entity-провайдером у нас, например? Это контракт, который задеплоен в юрисдикции. А вот в реальном мире кто будет деплоить эти контракты, кем они будут являться? Типа тот, кто деплоит адаптер к сети, то есть foundation, он деплоит и депозитарий, и entity-провайдер. И он вшивает его в кошелек. Да, но тогда получается, что... Можно вообще это все в этот, как его, конфиг, конфиг.json, просто через EP2 и юрисдикция entity-провайдера. Я сейчас ради прикола напишу LIDA, точка ETH, и тогда у нас получится, что понятно, что ETH – это юрисдикшен, LIDA – это некоторые... Я просто думал над каким-нибудь брендом из эфириума, то есть нет превосходства. Скорее, не бренд эфира, а способ работы этого entity-провайдера, потому что самый базовый – это вот этот с кворумами, но можно же реализовать в будущем любого уровня сложности. Там министерство... Что-то отвалилось? Еще раз, способ работы с этим... Это способ того, как управляется entity, кто может проголосовать за кворум, кто управляет ей и так далее. Есть стандартный, который мы зарелизим в начале, но это можно заменить, кто-то создать другую логику на уровне, я не знаю, как выбора президента, то есть какой-то своей логики, пока непонятно какой. То есть у нее есть интерфейс конкретный, который имплементирует точка рекавер, ханку, ты туда передаешь ханку, он тебе возвращает entity-ID. Я просто поэтому взял условное слово Лайда, как некоторый бренд, существующий внутри эфира, который объявил некоторый протокол, по которому этот entity-провайдер работает в рамках юрисдикции. Вот так. Круто. Кворум как определяется? Кворум вычисляется как в квадратной скобке threshold такой-то, потом набор сайнеров, запятая веса. Или просто массив сайнеров, запятая массив весов числа. И threshold, собственно, сколько надо весов набрать. И от этого берется кворум-хэш. Кворум-хэш хранится в entity-провайдере. Прости, прости, прости. Так, сейчас это будет. Я тогда пошел entity-провайдер делать. entity-провайдер... Так, сейчас надо записать. Defines protocol. How entity operates and resolves. Или как? Сettles, settles. Entity что делает? Ну, entity-провайдер – это смарт-контракт, куда деньги закинуты. И он решает, как потом эти деньги оттуда доставать, правильно? Ну, подожди, деньги в entity-провайдер, по-моему, не закидывают. В депозитарий закидываются деньги. Entity-провайдер отвечает за регистр ID и кворум, который им управляет. То есть, это таблица ID-шек, кто ими владеет. Ну, тут я сам точно не знаю, как надо сделать. Единственная вообще причина, почему entity-провайдер существует отдельно, это потому, что я не смог его засунуть в депозитарий. Потому что уперся в лимит, контракт-лимит. Так-то я хотел вообще все в один файл сделать. Registry of entities and their... По сути, это аккаунт-абстракт. То есть, таким словом называют абстракцию аккаунта, они в эфире это сейчас пытаются тоже добавить, чтобы ты мог начать пользоваться одним аккаунтом, а потом у тебя на этот Restify завязан на один адрес, а потом ты решил, надо отменить ключ, может меня обломали. Чтобы тебе не бегать по всему DeFi, ты каким-то образом подменяешь. И вот в entity-провайдере, собственно, это можно будет сделать. Ты начинаешь пользоваться с одним кворумом, даже не регистрируясь там, потому что у тебя entity ID, может быть, равен кворуму хэш. То есть, ты по умолчанию, если у тебя там на какой-то кворум хэш нулевые значения, значит, нулевые значения подразумеваются, что они равны твоему же ID-шнику. То есть, понял. Так, а потом вернемся к тому, что содержит в себе entity-провайдер. Так, адрес, бла-бла-бла. Вот, кворум. Кворум, ты хочешь, ты сейчас продиктовал, как выглядит кворум в полной версии, ну, типа, в финальной, но по факту это что такое? То есть, а, кворум, тогда это уже объект, потому что он должен иметь в себе треш-холд. Ну, либо объект, либо массив, где ты просто запоминаешь, что есть что. Нет, ну, это то, что в массиве... Скорее массив, потому что ты его должен в RLP-шку кидать. Я понимаю. Смотри, смотри, вот тут тоже двойственность. Мы сейчас описываем код из документейшн. Понятно, что когда будет имплементейшн, там должен быть RLP, и чтобы было RLP, объекты не подходят, будут массивы. Короче, да, помечать поля. В чем измеряются... Просто объект хорош тем, что можно именовать вещи. Да, да. Треш-холд в чем измеряется? Число, сколько весов надо набрать, сколько подписей от сайнера в этом кворуме нужно набрать, чтобы считать валидный это хантер от этого кворума. Это получается, ну, по факту, сколько весов, то есть, сколько суммарно шеров, да? Да. Треш-холд. Теперь, если ты ставишь 3, и там A, B, C, D, каждую по единице, тебе надо набрать три подписи минимум. Тогда, вернее, true. Required. И вот теперь смотри, для того, чтобы провалидировать блок, или для того, чтобы принять пропозал? Кворум, он вообще везде используется. То есть, все, что от лица эти ты проверяешь, и для блока... То есть, по сути, для подписи блока нужно собрать ханка, и для запроса в юрисдикцию нужно собрать ханка, потому что там будет везде функция .recoverhanka, чтобы можно было как first-class citizen использовать этот entity. Amount of shares collected to commit, не знаю, сейчас нет, to validate, to achieve consensus. To aggregate. To achieve consensus, да. Ну, achieve consensus, это связано только с блоками, чтобы создать валиду ханка от лица этой подписи, в том числе блоки. То есть, это не только на блоках используется, но и для всего остального. Первый уровень – это вы создаете блоки, подписываясь общим ханком. Второе – вы создаете транзакции в юрисдикцию, тоже подписываясь этим образом. И третье – это, чтобы кому-то другому через систему аккаунтов послать другой entity, вы тоже подписываетесь этим ханком. То есть, одна система для всего. Ух ты, прикольно, прикольно. Система подписи от лица сущности. То есть, аккаунт абстракция на уровне... Так, теперь, треш-холд – это сколько шеров нужно набрать. Ну, тогда надо добавить пример, например, треш-холд. Например, у тебя сущность с кворумом ABC, 2 из 3 надо набрать. Нет, я бы взял что-то более такое, где шеры могут быть, это ты, когда у чуваков равные голоса, у них могут быть же неравные голоса, правильно? Или мы это скипаем сейчас? Могут быть неравные, да. Тогда не 2 из 3. Нет, не надо объяснять, я хочу записать полную версию. Тогда, скажем, например, total shares равно 1000, значит, Signer A has 100 shares. Окей. Signer B – 200. Нет, давай так, 300, 300, 300 и 100. Окей. Ага, треш-холд – 600. И теперь получается, ага, кворум есть, и теперь мемберы кворума – это, собственно, сайнеры. Сайнеры – это пары, вот, интересно. Сайнер – это просто адрес, который сгенерился, один из ответов. Именно адрес надо указывать, потому что айдишка, но юридикция не поймет, что это айдишка. Ага, мембер – это массив в любом случае, и тогда у него есть адрес и количество шеров, правильно? Шеров можно отдельно сделать, то есть массив адресов и массив шеров. Ну, а какая разница? Ну, типа, проще, когда у тебя не массив массивов, а два отдельных массива. Нет, а если эфиры, РЛП покороче получается. Хорошо, это записано, так, типа, мембер can be later represented as array of addresses plus array of shares. Да, for better RLP. Да, то есть сейчас я это написал, как массив объектов, где, типа, адрес, количество шеров. Ага, так, хорошо, это мы описали кворум, теперь блок пропозер – это у нас, это адрес тоже, да, наверное, будет, или айдишник сайнера. Блок пропозер? Да. Просто по умолчанию не будем больше заморачиваться. То есть первый, который сайнер, который указан в кворуме. Ну а в целом, как он может задаваться, резолвиться? Ну, адресом сайнера. Адресом или айдишником? Ну, не принципиально, адресом. Окей. Оно же туда-сюда вычисляется, из айдишника.

А что он там хотел? Просто самый первый. И в списке он как бы по умолчанию ты пишешь самым большим весом. То есть, если у тебя у одного пять, у остальных по два, соответственно, проще сделать у того, у кого пять пропозер. Все равно он самый главный. Это адрес сайнера, который ответственный за пропозицию блока. Дефолт на... Эти мемберы... А вот, кстати, интересно... А, ну, похуй. Да, наверное, надо убрать слово мемберы, потому что мемберы это и есть сайнеры. Не надо вводить никакого нового слова. Сайнерс. Так, хорошо. Блок пропозер — это адрес конкретного пацана. Теперь дальше. И она знает стейдж, в котором она находится. Стейдж — это типа idle, пропозит, вот это вот. Скорее, мне нравится ready, типа готово, и send. Типа отправил сейчас на подпись другим. Но это flexible, то есть в процессе может стать понятно, что надо что-то еще добавить и так далее. Какие-то другие статусы. Стоит... Так, говоришь ready, потом какой? Send. Отправлено на подпись другим валидаторам. Ну, я бы сказал, что это скорее awaiting какой-нибудь, типа... Ну, окей. Типа send, я, значит, уже отправил блок на... Это ты отправил, а относительно состояния реплики слова send, это типа она отправлена как будто бы. Кто? Реплика отправлена на подпись? Нет. Это у блока может быть send, а состояние реплики... Ну, я типа сейчас отправилась на подпись фрейма, поэтому я не готов отправлять следующий. А если готово, ready, то типа можешь сейчас отправить в этом серверном... Тебе. Ну, допустим. Я сейчас не буду спорить, но я понял главную мысль. Значит, stage ready. Дальше mempool. Mempool, понятно, что такое. Это просто пачка, куда слетаются... Вот, кстати, давай все-таки подпишем. Мемпулл энтити, да, это... Приведи пример транзакции энтити. Это все-таки команды, может быть, к энтити? Нет-нет, чаты. Команды — это то, что выполняет реплика. А транзакции — это то, что выполняется уже внутри фрейма, со стейтом. То есть уже сами действия внутри. А команды — это уровни консенсуса. Типа давай транзакцию, предложить блок... Ну вот где они хранятся? У кого они, уровень консенсуса, у кого он хранится? У реплики. Реплика — самый внешний слой машины. Потом внутри уже фрейм. Так, хорошо. Значит, вот. А mempool над фреймом существует. Значит, у нас есть mempool, где хранятся транзакции. mempool of transactions. Даже давай допишем entity transactions для полноты. Вот, но тогда, получается, где-то рядом. А команды где лежат? А команды, они лежат на уровне сервера. Да, согласен. Если ты используешь серверный фрейм, он знает, какие команды я скормил. Вот сумму команд, которые скормил конкретную энтити в этот конкретный тик. Это может быть импорт, это добавить транзакции в mempool реплики. Это предложить или подписать фрейм. Надо куда-то добавить, что это надо сделать. Значит, mempool servers to do. Add servers mempool for commands. Пускай будет так. Так, значит, у нас есть mempool для transactions. Давай какой-нибудь пример транза туда всунем. Пример транза. У нас будет только чат. Просто текстное сообщение. Ну да, но опиши. Тип чат, дата, текст. Тип. А, ну еще, типа, кто послал. Вот смотри, тит, да, вот, вот, вот, from обязательно. From signer. По-хорошему, это должна быть подпись, ну, типа, signature будет, да, signature. То есть, именно не hank, а именно signature, потому что ты от сырого сайнера получаешь 64 байта. И уже... А теперь смотри, type или, вот, в некоторых случаях, в транзакциях используют слово op, типа, operation. Мы type используем? Ну, type тем более. Да, понятно, я согласен. Согласен. Так. Хорошо. Значит, type, чат. Дата, message, hello world, окей. Зачем здесь as any висит? Хуй с ним, пока не нужен. Так, дальше у меня есть штука blocks, но теперь это frames. Вот, frames, это как будто бы, значит, у entity-реплики это вообще пачка всех блоков, которые вообще когда-либо были. Не совсем. Энтити-реплика — это основное состояние машины, которое составляет mempool, ссылку на финальный, последний фрейм, и ссылку на новый фрейм, который вы сейчас создаете, и набор hank. То есть, представь иголку, как вот... Да, а, то есть... Чеки, на которые появятся чеки, знаешь, на иголку. Да, да. И она, по идее, должна храниться отдельно от frames, потому что неудобно ее внутри фрейма подписи хранить. Это дополнительный раунд потребует консенсуса. Точняк, сейчас. У нас в mempool'е у транзакции еще есть from, type, data и signature. Signature. По идее, from не понадобится, когда будет signature, потому что из signature сразу получаешь, типа, recover, sign up. Уже узнаешь из подписи, которая у тебя... Ну, так работает Ethereum. То есть, ты пишешь recover... Сайнер в любом контракте дает сюда signature и хэш, который подписан на вход, и он тебе возвращает адрес того, кто это подписал. То есть, тебе нет смысла отдельно говорить, кто это подписал, ты просто recover'ишь. Вот. И ты, получая транзакцию от того, кто тебе прислал, ты ее уже внутри фрейма обрабатываешь. Так, поехали. А, ну еще, наверное, нонса нужна. Нонса у кого? Нонса у фрейма. У транзакции. А, это от реплея, да. И она, соответственно, должна храниться, будет в стейте entity, то есть внутри фрейма. Где, типа, сайнер такая-то нонса, и каждый раз плюс один, когда у тебя от него какая-то транзакция исполнилась. Чтобы она заново не была валидна, эта транзакция. Так, сейчас посмотрим. Окей. Смотри, я закончил mempool, в нем одна транзакция. Теперь frames. Тогда не frames, а просто frame. Еще раз, у нас есть... Да-да-да, последний фрейм. У нас есть last frame. Финальный фрейм, финальный. То есть, это то состояние, на котором сейчас реплика зафиксирована, которая финализована. То есть, фрейм-система. Может, current? Можно current, можно current frame. Ну, final просто более утверждающий звучит. Типа, final, то, о чем вы финализировали. Это же устойчивое изображение в консенсусе. То есть, final и консенсус фрейма – это то, что вы обсуждаете, то, что вы сейчас собираетесь делать. Он еще не финализовался. Final и консенсус, например. Или final и next. Так, final frame. У final фрейма есть высота. Да. У current фрейма, прости. Timestamp. Transactions. Это транзакции, которые в него уже попали. Их адресовать не надо. State hash? Ну, да. Entity state. Даже не hash, просто entity state. Мы будем сейчас все пихать прямо внутрь. То есть, это просто в лбзе какие-то разные стейты. Мы не будем даже задавать внешние ссылочки. Это все. Тикнуть можно потом. Значит, в current фрейме текущий стейт – это, собственно… Ну, ты чат хотел сделать? Не каунтер. Соответственно, будет просто state.chat равно массив сообщений. И его просто пушишь. Пушишь туда сообщение, которое в транзакции, собственно… Так, тогда получается чат. И это массив это, да? Или как назвать массив? Точка messages или точка log? Чат – это хорошо. Потому что чат – это… Entity state в данном случае – это как то, что мы называли store. Типа, то, что хранит текущие значения. И тогда в entity state чат находится в некотором состоянии, где он может быть… Типа, вот несколько сообщений. Так. Hello, Bob. Hello, Alice. Так, from 1 to… Так, так, так, да, чат, окей. Есть сообщение. Entity state. Записали. У нас в чате есть несколько сообщений. Это текущий стейт. Значит, в current фрейме у него есть высота, а в current фрейме у него нет высоты. Это текущий стейт. Значит, в current фрейме у него есть высота, timestamp транзакции. Транзакции, они как бы претендуют на то, чтобы добавиться в следующий стейт. Подожди, что значит добавиться в следующий стейт? Ну смотри, у нас есть current фрейм. В нем транзакции, которые в этом же фрейме были исполнены и привели к тому стейту, который в этом фрейме. То есть ты хранишь во фрейме, ну как в блоке это сделано, в эфире. Блок же ссылается на транзакции, которые в нем содержатся. А потом он ссылается на стейт, который получился. Окей, тогда… То есть ты говоришь, кто применил и что получилось. И на всем этом деле подписываешься. Тогда я напишу на всякий случай несуществующая virtual field. А я напишу genesis frame. А зачем? Я же говорю, что он виртуальный. Я даже закомменчу, что это пример будет. У него высота нулевая, таймстэмп нулевой, у него пустые транзакции. Я про то, что изобразить стейт пустого чата. Он начался с пустого чата. По сути, как генезис фрейм, это и есть генезис состояния. Да. И получается, current frame у него первое. И вот его и импортировать будет input в начале. Import entity. И тогда транзакции – это как раз вот эти новые сообщения, которые попали в чат. Отлично. Так. Entity state равно prev state. О, подожди, это что? Это я комментарии подписываю. Как вы числяете, ты имеешь в виду, entity state равно то, что было до, точнее, apply, скобочка, старый стейт. Apply prev state, запятая transactions. Я там думаю, скорее весь фрейм надо передавать, а не только старый стейт, чтобы дополнительные параметры были в виде… Ну, это, короче, разберешься. Да, да. Так, это мы описали current frame, который… Ну да, current согласен, неплохо, впускай будет final. Final тоже плохо, last frame. Да почему плохо-то? И current, и final одинаково передают смысл, что это вот то, чем все остальные реплики согласны, то, что у остальных реплик. А то, что у тебя локально, вот ты сейчас пропозер, ты создаешь консенсус frame, и ты сам применил только что транзакции, но остальные еще с ними не согласились. И тогда получается это что будет? Next frame, proposed frame? Я думаю, не надо даже его хранить как frame, можно просто хранить самое основное. Что требуется для того, чтобы создать новый фрейм? Чем он отличается? Тайт хранить не надо, потому что это плюс-плюс-один. Таймштамп надо. То есть ты хранишь next таймштамп. А кто это? Как мы его подпишем, где мы это храним? А можно даже его… Ну не знаю, просто основные поля, которые нужны, чтобы его вычислить из текущего состояния. То есть это next таймштамп, это число может быть уникальным. Окей, давай я напишу просто next пока, а там разберемся. Next таймштамп, да. Не, а вот и у next есть что? Ты можешь прямо в реплике хранить просто параметр next таймштамп и параметр next transactions. То есть те транзакции, которые в следующий фрейм ты включил. Так. И, например, next state можно также хранить прямо на данном этапе и также просто текстом весь. И всех этих трех параметров достаточно, чтобы создать этот… Подожди, next transactions это разве не mempool? Нет, не mempool. Ты из mempool берешь и перекладываешь в next фрейм, да. И перекладываешь в next transactions. А в это время, пока ты в состоянии подписан, тебе mempool может дальше пополняться. То есть пока ты ждешь, ты просто в mempool получаешь новое. Так. Transactions у него есть. Так. таймстамп next frame это следующие транзакции. Вот. И что у него есть у next frame? У него подписи пока нет, она не здесь хранится. А где хранится список тех, кто провалидировал его? Кто провалидировал? Ну, там же, в реплике. В реплике ты хранишь подписи. Вот этот huncomap. То есть ты, по сути, агрегируешь вот этот вот receipt для конкретного хэша. Но пока не заморачивайся. Просто, допустим, пропусти это так, что подписи сами провалидируем. Сейчас ко мне друг зайдет через пару минут. Да, окей. Давай основные методы, на чем мы остановились. Вроде какие-то зияющие дыры, вроде мы все закрыли. То есть вот это вот, как импортируется, ты понял? То есть в северный mempool попадает input, который импортирует. Вот давай, вот давай. Как раз его и опишем. Input приходит, который импортирует. У input'а что есть? У input'а есть там... Нет, ну from уже не важен, потому что хуй знает. Короче, да. Опиши мне input, который бы инициализировал вот эту entity первым. Input состоит из кучи разных полей. Типа, точка import, это значит, это поле, то, что импортировать. Добавить транзакции, это набор транзакций, чтобы мы в одну функцию просто послали вот этот input, и она уже внутри по очереди делала. Сначала типа, если что-то импортировать, импортируем. Тогда это type какой-то есть, правильно? А, input это набор команд всяких, да? Сборка, да, сборная, чтобы в одну функцию вместить все это. Не через запятую много input'ов, а один жирный input, в котором разные поля. И первое поле это import. Второе поле это, например, добавить какие-то транзакции в ним. Третье поле это предложить или подписать блок. Смотри, это получается import entity. У import entity какие-то данные есть, наверное, да? Ну, да. Да, и это именно основное поле, это просто, ну, например, frame. Current frame просто RLP закодированный, который надо испортить. Или даже не знаю, может быть не current frame, а реплику саму. Просто вся реплика вместе с... Хотя нет, реплики с anirid'и указаны, он не нужен. И mempool в принципе не нужен. Так, хорошо. Мы импортировали entity. Что мы еще? Наверное, frame все-таки. Просто импортировать последний frame. И все, у тебя отживает, так сказать, появляется реплика твоя. Да. А, подожди, а когда мы импортировали реплику, а quorum где описан? Quorum внутри фрейма. То есть, внутри состояния фрейма он должен храниться. Там же, где chat, вот это все. Реально? Quorum находится внутри состояния? Я думаю, так лучше. Чтобы все важные штуки внутри состояния. А, чтоб мы могли его понять.

поменять, конечно. Да, в будущем зачем менять, то есть все по максимуму засовывается внутрь состояния, оно у всех одинаковое, синхронизованное и логика можно будет его менять как-то. Вау, вот, ну, короче, да, видишь, тут много чего плавает туда-сюда, поэтому очень сложно... Постепенно, постепенно. Entity state... Ладно, это сейчас, подожди, я это просто помечу, to do, move quorum to entity state, to current frame... Entity state... Чем отличается entity state от current frame? А, все, вижу, вижу, вижу, все. Entity state живет внутри current frame, current frame – это плюс еще один штамп, да, и набор инпута. По сути, state – это под state, то есть, frame – это реальный state системы, а state – это как бы под state, вот поэтому мне слово блока не нравится, потому что блока есть в state. Quorum to current frame... Окей, окей, ну, я на всякий случай этот черновик тебе сейчас в GIST скину, просто чтобы было, но продолжить надо вместе будет. Круто, слушай, вот это сейчас вообще круто было. Огонь, огонь. Да, ну, в общем-то, я сам понял, то есть, просто не надо пытаться понять, как я это вижу, а просто понять, с какой задачей это решают. Это блокчейн, то есть, тут, де-факто, я ничего нового не забыл, это просто локальный блокчейн, в котором еще один блокчейн, в котором еще новый. Да, да, да, чувак, и я это кручу, верчу, и, блядь, с ума схожу. Я уж думал... Это придется пройти. Не, я, я, я, я, да, ну, типа, ну, я надеюсь, ты понимаешь, что я не ебланю, а я реально, типа, стараюсь. Да, я знаю. Вот, окей, тогда давай на связи. Давай. Пока-пока. Мне кажется, смотри, вот то, что есть, и ты... Угу. Это забрунешь в чат GPT, предыдущие те штуки, и если ты ему будешь спрашивать, мне почему-то кажется, что он ответит похоже, чем я. Вот, если тебе кажется, что он хуйню отвечает, давай мне, я буду поправлять спеку. Я много крутых штук с ними понял за те 2 недели, что дрочил в сухомятку. В общем, пользы есть. О том, что, как чистые машины делать, вот, но со всем, что ты сказал, типа, негативным, поэтому по поводу слопа я абсолютно согласен, я его воспринимал чисто как черновики, которые мне позволяют выхватить фрагментами что-то полезное. Вот. Я, естественно, не считал... Да, к сожалению, сами чаты, они натренированы на... На слоп. Устаревших, устаревших данных. То есть, большинство людей даже не понимают блокчейн, они верят, что надо, блядь, хранить 700 гигабайт, что их надо синхронизировать. То есть, ментальную модель надо менять под корень. Угу. Поэтому я периодически заново обучаю сами чаты, типа, вот, что за бред ты мне там говоришь? Что значит? Биткоин тяжело быть в фулл ноды, потому что должен скачать 700 гигабайт, а нахуя? И он такой, блин, да, реально не надо. То есть, они все обучены на вот эти слопы. Ну, конечно, не, понятно, они знают на том, что на статус-кво. Они выдают тебе статус-кво всегда. Это их суть. Да. Вот, окей. Сейчас, дай, я чуть переварю. Вообще круто, спасибо большое. Два часа. Два часа, ахуеть вообще, как будто нет. Круто, давай. О, как раз друг стучит. Давай. Круто. Тихо. Тихо, тихо. Тихо, тихо, тихо. Тихо, тихо. Тихо, тихо. Тихо, тихо. Тихо, тихо. Тихо, тихо. Тихо, тихо. Тихо, тихо. Тихо, тихо. Тихо, тихо. Тихо, тихо. Тихо, тихо. Тихо, тихо. Тихо, тихо. Тихо, тихо. Тихо, тихо. Тихо, тихо. Тихо, тихо. Тихо, тихо. Тихо, тихо. Тихо, тихо. Тихо, тихо.